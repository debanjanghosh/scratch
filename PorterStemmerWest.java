/* * Created on Sep 10, 2003 * * * Porter stemmer in Java. The original paper is in * * Porter, 1980, An algorithm for suffix stripping, Program, Vol. 14, no. 3, pp 130-137, * * See also http://www.tartarus.org/~martin/PorterStemmer * * History: * * Release 1 * * Bug 1 (reported by Gonzalo Parra 16/10/99) fixed as marked below. * The words 'aed', 'eed', 'oed' leave m_k at 'a' for step 3, and m_b[m_k-1] * is then out outside the bounds of m_b. * * Release 2 * * Similarly, * * Bug 2 (reported by Steve Dyrdahl 22/2/00) fixed as marked below. * 'ion' by itself leaves m_j = -1 in the test for 'ion' in step 5, and * m_b[m_j] is then outside the bounds of m_b. * * Release 3 * * Considerably revised 4/9/00 in the light of many helpful suggestions * from Brian Goetz of Quiotix Corporation (brian@quiotix.com). * * Release 4 * **************************************************************************** * Modifications by Hugo Molina-Salgado                                    * * August 28,2003                                                                     * *                                                                                             * * added some changes to make it compatible with weststem.c: * * Modifications by Alex Zhou * April 27, 2005 * * removed the hard-coded exception and stop word lists. *                                                                                             * **************************************************************************** *                                                                                             * *                     Copyright 1990,1991 by the                                * *                  Information Retrieval Laboratory,                             * *                     University of Massachusetts,                              * *                          Amherst MA. 01003                                      * *                         All Rights Reserved.                                       * *            Do not distribute without written permission.                  * *                                                                                             * **************************************************************************** */package com.rutgers.util;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.Reader;import java.text.BreakIterator;import java.util.ArrayList;import java.util.Hashtable;import java.util.StringTokenizer;//import com.thomson.research.app.IRuntimeConfiguration;/** * * Default West Porter Stemmer. * * * * @author Hugo Molina-Salgado * * */public class PorterStemmerWest implements Stemmer{    private final static String STOPWORD_PROP_NAME = "dictionary.stopword";    private final static String EXCEPTION_WORD_PROP_NAME =        "dictionary.exceptionword";    private final static String DEFAULT_STOPWORD_LIST = "config/stopWords_small.txt";    private final static String DEFAULT_EXCEPTION_WORD_LIST =        "config/exceptionWord.lst";    private char[] m_b;    private int m_i, /* offset into m_b */    m_iEnd, /* offset to end of stemmed word */    m_j, m_k;    private static int s_inc = 100;    /* unit of size whereby m_b is increased */    private static String s_empty = "";    private static Hashtable<String, String> s_stopWords;    private static Hashtable<String, String> s_exceptionWords;    public PorterStemmerWest()    {    	 m_b = new char[s_inc];         m_i = 0;         m_iEnd = 0;    }    /**     *     * Constructor     *//*    public PorterStemmerWest( IRuntimeConfiguration conf ) throws IOException    {        initStopWords( conf );        initExceptionWords( conf );        m_b = new char[s_inc];        m_i = 0;        m_iEnd = 0;    }    */    /**     *     * Add a character to the word being stemmed. When you are finished adding     *     * characters, you can call stem(void) to stem the word.     *     *     *     * @param ch     *     *            character to be added     */    public void add( char ch )    {        if ( m_i == m_b.length )        {            char[] newB = new char[m_i + s_inc];            for ( int c = 0; c < m_i; c++ )            {                newB[c] = m_b[c];            }            m_b = newB;        }        m_b[m_i++] = ch;    }    /**     *     * Adds wLen characters to the word being stemmed contained in a portion of     *     * a char[] array. This is like repeated calls of add(char ch), but faster.     *     *     *     * @param w     *     *            character array of characters to add     *     * @param wLen     *     *            integer number of characters to add     */    public void add( char[] w, int wLen )    {        if ( m_i + wLen >= m_b.length )        {            char[] newB = new char[m_i + wLen + s_inc];            for ( int c = 0; c < m_i; c++ )            {                newB[c] = m_b[c];            }            m_b = newB;        }        for ( int c = 0; c < wLen; c++ )        {            m_b[m_i++] = w[c];        }    }    /**     *     * After a word has been stemmed, it can be retrieved by toString(), or a     *     * reference to the internal buffer can be retrieved by getResultBuffer and     *     * getResultLength (which is generally more efficient.)     *     *     *     * @return String stemmed word     */    public String toString()    {        return new String( m_b, 0, m_iEnd );    }    /**     *     * Returns the length of the word resulting from the stemming process.     *     *     *     * @return int result length     */    public int getResultLength()    {        return m_iEnd;    }    /**     *     * Returns a reference to a character buffer containing the results of the     *     * stemming process. You also need to consult getResultLength() to determine     *     * the length of the result.     *     *     *     * @return char[] result buffer contents as a character array     */    public char[] getResultBuffer()    {        return m_b;    }    /* cons(m_i) is true <=> m_b[m_i] is a consonant. */    /**     *     * Checks if a token is a punctuation.     *     *     *     * @param token     *     *            (in local) is a string.     *     * @return true if the string is a punctuation symbol. false otherwise.     */    private boolean isPunctuation( String token )    {        boolean punct = false;        char a_char;        if ( token.length() == 1 )        {            a_char = token.charAt( 0 );            if ( Character.isDigit( a_char ) || Character.isLowerCase( a_char )            || Character.isUpperCase( a_char ) || a_char > 127 )            {                // is a digit or upper or lower case char;                punct = false;            }            else if ( a_char == '-' )                punct = false;            else                // else consider it a punctuation symbol                punct = true;        }        return punct;    }    private final boolean cons( int i )    {        // System.out.println("[STEMMER: cons]" + m_b[i]);        switch ( m_b[i] )        {            case 'a':            case 'e':            case 'i':            case 'o':            case 'u':                return false;            case 'y':                return (i == 0)                    ? true                    : !cons( i - 1 );            default:                return true;        }    }    /*     *     * m() measures the number of consonant sequences between 0 and m_j. if c is     *     * a consonant sequence and v a vowel sequence, and <..> indicates arbitrary     *     * presence,     *     *     *     * <c><v> gives 0 <c>vc<v> gives 1 <c>vcvc<v> gives 2 <c>vcvcvc<v> gives     *     * 3 ....     */    // modifiied by HMS 08-29-03    private final int m()    {        int n = 0;        int i = 0;        while ( cons( i ) )        {            if ( i >= m_j + 1 )            {                return n;            }            i++;        }        i++;        while ( true )        {            while ( !cons( i ) )            {                if ( i >= m_j + 1 )                {                    return n;                }                i++;            }            i++;            n++;            while ( cons( i ) )            {                if ( i >= m_j + 1 )                {                    return n;                }                i++;            }            i++;        }    }    /* vowelinstem() is true <=> 0,...m_j contains a vowel */    private final boolean vowelinstem()    {        int i;        for ( i = 0; i < m_j + 1; i++ )        {            if ( !cons( i ) )            {                return true;            }        }        return false;    }    /* doublec(m_j) is true <=> m_j,(m_j-1) contain a double consonant. */    private final boolean doublec( int j )    {        if ( j < 1 )        {            return false;        }        if ( m_b[j] != m_b[j - 1] )        {            return false;        }        return cons( j );    }    /*     *     * cvc(m_i) is true <=> m_i-2,m_i-1,m_i has the form consonant - vowel -     *     * consonant and also if the second c is not w,x or y. this is used when     *     * trying to restore an e at the end of a short word. e.g.     *     *     *     * cav(e), lov(e), hop(e), crim(e), but snow, box, tray.     */    private final boolean cvc( int i )    {        if ( i < 2 || !cons( i ) || cons( i - 1 ) || !cons( i - 2 ) )        {            return false;        }        {            int ch = m_b[i];            if ( ch == 'w' || ch == 'x' || ch == 'y' )            {                return false;            }        }        return true;    }    // modified by HMS 08-29-03    private final boolean ends( String s )    {        int l = s.length();        int o = m_k - l + 1;        // if (o < 0) return false;        if ( l > m_k )        {            return false;        }        for ( int i = 0; i < l; i++ )        {            if ( m_b[o + i] != s.charAt( i ) )            {                m_j = m_k;                return false;            }        }        m_j = m_k - l;        return true;    }    /*     *     * setto(s) sets (m_j+1),...m_k to the characters in the string s,     *     * readjusting m_k.     */    private final void setto( String s )    {        int l = s.length();        int o = m_j + 1;        for ( int i = 0; i < l; i++ )        {            m_b[o + i] = s.charAt( i );        }        m_k = m_j + l;    }    /* r(s) is used further down. */    private final void r( String s )    {        if ( m() > 0 )        {            setto( s );        }    }    // ORIGINAL COMMENT IN WESTSTEM.C : (added by HMS 08-28-03)    /* ----------------------------------------------------- */    /* I added step0 to strip apostrophe s from terms. */    /* JDF 10/19/92 */    /* ----------------------------------------------------- */    private final void step0()    {        if ( m_b[m_k] == 's' )        {            if ( ends( "'s" ) )            {                m_k -= 2;            }        }    }    /*     *     * step1() gets rid of plurals and -ed or -ing. e.g.     *     *     *     * caresses -> caress ponies -> poni ties -> ti caress -> caress cats -> cat     *     *     *     * feed -> feed agreed -> agree disabled -> disable     *     *     *     * matting -> mat mating -> mate meeting -> meet milling -> mill messing ->     *     * mess     *     *     *     * meetings -> meet     */    private final void step1()    {        if ( m_b[m_k] == 's' )        {            if ( ends( "sses" ) )            {                m_k -= 2;            }            else if ( ends( "ies" ) )            {                setto( "i" );            }            else            {                // if (m_b[m_k-1] != 's') m_k--;                // ORIGINAL COMMENT IN WESTSTEM.C : (added by HMS 08-28-03)                /* ADDED BY IR-LAB - THIS IS NOT PART OF THE ALGORITHM */                /*                 *                 * if (m_k) Added by IM 03/16/99                 */                /* if m_k = 0; penult_c accesses uninitialized memory */                if ( m_k != 0 )                {                    if ( !ends( "ous" ) && m_b[m_k - 1] != 's' && m_k + 1 > 3 )                    {                        m_k--;                    }                }            }        }        if ( ends( "eed" ) )        {            if ( m() > 0 )            {                m_k--;            }        }        else        {            // ORIGINAL COMMENT IN WESTSTEM.C : (added by HMS 08-28-03            /* ADDED BY IR-LAB - THIS IS NOT PART OF THE ALGORITHM */            if ( m_k + 1 < 4 )            {                return;            }            // end of added code            if ( (ends( "ed" ) || ends( "ing" )) && vowelinstem() )            {                m_k = m_j;                if ( ends( "at" ) )                {                    setto( "ate" );                }                else if ( ends( "bl" ) )                {                    setto( "ble" );                }                else if ( ends( "iz" ) )                {                    setto( "ize" );                }                else if ( doublec( m_k ) && m_b[m_k] != 's' && m_b[m_k] != 'l'                && m_b[m_k] != 'z' )                {                    // modified by HMS to refleft weststem.c 09-09-2003                    m_k--;                }                else                /* THE `wordlength' (m_k+1 < 3) PART WAS ADDED BY THE IR LAB */                if ( m() == 1 && cvc( m_k ) || m_k + 1 < 3 )                {                    setto( "e" );                }            }        }    }    /* step2() turns terminal y to m_i when there is another vowel in the stem. */    private final void step2()    {        // if (m_k != 0) added by HMS 08-28-03        if ( m_k != 0 )        {            if ( ends( "y" ) && cons( m_k - 1 ) && vowelinstem() ) // &&                                                                   // cons(m_k -            // 1) added by            // HMS 08-28-03            {                m_b[m_k] = 'i';            }        }    }    /*     *     * step3() maps double suffices to single ones. so -ization ( = -ize plus     *     * -ation) maps to -ize etc. note that the string before the suffix must     *     * give m() > 0.     */    private final void step3()    {        if ( m_k == 0 )        {            return; /* For Bug 1 */        }        switch ( m_b[m_k - 1] )        {            case 'a':                if ( ends( "ational" ) )                {                    r( "ate" );                    break;                }                if ( ends( "tional" ) )                {                    r( "tion" );                    break;                }                break;            case 'c':                if ( ends( "enci" ) )                {                    r( "ence" );                    break;                }                if ( ends( "anci" ) )                {                    r( "ance" );                    break;                }                break;            case 'e':                // ORIGINAL COMMENT IN WESTSTEM.C : (added by HMS 08-28-03)                /* THE `ater' PART WAS ADDED BY THE IR-LAB */                if ( ends( "ater" ) )                {                    r( "ate" );                }                else if ( ends( "izer" ) )                {                    r( "ize" );                }                break;            case 'l':                if ( ends( "bli" ) )                {                    r( "ble" );                    break;                }                if ( ends( "alli" ) )                {                    r( "al" );                    break;                }                if ( ends( "entli" ) )                {                    r( "ent" );                    break;                }                if ( ends( "eli" ) )                {                    r( "e" );                    break;                }                if ( ends( "ousli" ) )                {                    r( "ous" );                    break;                }                // ORIGINAL COMMENT IN WESTSTEM.C : (added by HMS 08-28-03)                /* THIS CLAUSE WAS ADDED BY THE IR-LAB */                if ( ends( "ionalli" ) )                {                    if ( m_b[m_k - 7] == 't' && m_b[m_k - 8] == 'a' )                    {                        m_j -= 2;                        r( "ate" );                        break;                    }                }                break;            case 'o':                if ( ends( "ization" ) )                {                    r( "ize" );                    break;                }                if ( ends( "ation" ) )                {                    r( "ate" );                    break;                }                if ( ends( "ator" ) )                {                    r( "ate" );                    break;                }                break;            case 's':                if ( ends( "alism" ) )                {                    r( "al" );                    break;                }                if ( ends( "iveness" ) )                {                    r( "ive" );                    break;                }                // ORIGINAL COMMENT IN WESTSTEM.C : (added by HMS 08-28-03)                /*                 *                 * MISSING A CLAUSE FOR `fulness' HERE. THIS APPEARS TO BE FOR                 * THE                 *                 * BETTER, SO IT WAS LEFT THIS WAY. IT NOW PREVENTS                 *                 * `USEFULNESS->USE', `MEANINGFULNESS'->MEANING'. INSTEAD                 *                 * `USEFULNESS->USEFUL'                 */                // commented to comply with weststem.c (added by HMS 08-28-03)                // if (ends("fulness")) { r("ful"); break; }                if ( ends( "ousness" ) )                {                    r( "ous" );                    break;                }                break;            case 't':                if ( ends( "aliti" ) )                {                    r( "al" );                    break;                }                if ( ends( "iviti" ) )                {                    r( "ive" );                    break;                }                if ( ends( "biliti" ) )                {                    r( "ble" );                    break;                }                break;            // commented to comply with weststem.c (added by HMS 08-28-03)            // case 'g': if (ends("logi")) { r("log"); break; }        }    }    /* step4() deals with -ic-, -full, -ness etc. similar strategy to step3. */    private final void step4()    {        switch ( m_b[m_k] )        {            case 'e':                if ( ends( "icate" ) )                {                    r( "ic" );                    break;                }                if ( ends( "ative" ) )                {                    r( "" );                    break;                }                if ( ends( "alize" ) )                {                    r( "al" );                    break;                }                break;            case 'i':                if ( ends( "iciti" ) )                {                    r( "ic" );                    break;                }                break;            case 'l':                if ( ends( "ical" ) )                {                    r( "ic" );                    break;                }                if ( ends( "ful" ) )                {                    r( "" );                    break;                }                break;            case 's':                if ( ends( "ness" ) )                {                    r( "" );                    break;                }                break;        }    }    /* step5() takes off -ant, -ence etc., in context <c>vcvc<v>. */    private final void step5()    {        if ( m_k == 0 )        {            return; /* for Bug 1 */        }        switch ( m_b[m_k - 1] )        {            case 'a':                if ( ends( "al" ) )                {                    break;                }                return;            case 'c':                if ( ends( "ance" ) )                {                    break;                }                if ( ends( "ence" ) )                {                    break;                }                return;            case 'e':                if ( ends( "er" ) )                {                    break;                }                return;            case 'i':                if ( ends( "ic" ) )                {                    break;                }                return;            case 'l':                if ( ends( "able" ) )                {                    break;                }                // ORIGINAL COMMENT IN WESTSTEM.C : (added by HMS 08-28-03)                /* THIS CLAUSE WAS ADDED BY THE IR-LAB */                if ( ends( "li" ) && m_k > 2 )                { // m_k > 2 : added by HMS 08-29-03                    // System.out.println("step5, case l: " + (new String(m_b,                    // 0,                    // m_i)));                    if ( (m_b[m_k - 2] != 'l') && (m_b[m_k - 2] != 'p')                    && (m_b[m_k - 2] != 'b') && (m_b[m_k - 2] != 'g')                    && m() != 0 )                    {                        m_k = m_j;                    }                    break;                }                if ( ends( "ible" ) )                {                    break;                }                return;            case 'n':                if ( ends( "ant" ) )                {                    break;                }                if ( ends( "ement" ) )                {                    break;                }                if ( ends( "ment" ) )                {                    break;                }                /* element etc. not stripped before the m */                if ( ends( "ent" ) )                {                    break;                }                return;            case 'o':                if ( ends( "ion" ) && m_j >= 0                    && (m_b[m_j] == 's' || m_b[m_j] == 't') )                {                    break;                }                /* m_j >= 0 fixes Bug 2 */                if ( ends( "ou" ) )                {                    break;                }                /* takes care of -ous */                return;            case 's':                if ( ends( "ism" ) )                {                    break;                }                return;            case 't':                if ( ends( "ate" ) )                {                    break;                }                if ( ends( "iti" ) )                {                    break;                }                // ORIGINAL COMMENT IN WESTSTEM.C : (added by HMS 08-28-03)                /* THIS CLAUSE WAS ADDED BY THE IR-LAB */                if ( ends( "ati" ) )                {                    break;                }                return;            case 'u':                if ( ends( "ous" ) )                {                    break;                }                return;            case 'v':                if ( ends( "ive" ) )                {                    break;                }                return;            case 'z':                if ( ends( "ize" ) )                {                    break;                }                return;            default:                return;        }        if ( m() > 1 )        {            m_k = m_j;        }    }    /* step6() removes a final -e if m() > 1. */    // original from PorterStemmer, commented by HMS 08-28-03    /*     *     * private final void step6() { m_j = m_k; if (m_b[m_k] == 'e') { int a =     *     * m(); if (a > 1 || a == 1 && !cvc(m_k-1)) m_k--; } if (m_b[m_k] == 'l' &&     *     * doublec(m_k) && m() > 1) m_k--; }     */    // version of step6() from weststem.c (added by HMS 08-28-03)    private final void step6()    {        if ( m_k == 0 )        {            return; /* for Bug 2? */        }        m_j = m_k;        // if ("true".equals( (String) System.getProperty("mel.debug")))        // {        // m_logger.debug("m_k: " + m_k);        // }        /* THE `m_b[m_k]==m_i' PART WAS ADDED BY THE IR-LAB */        if ( m_b[m_k] == 'e' || m_b[m_k] == 'i' )        {            if ( m() > 1 )            {                m_k--;            }            else            {                /*                 *                 * THIS CLAUSE IS ALSO DIFFERENT FROM PORTER (IT SHOULD HAVE                 *                 * !CVC() INSTEAD OF THE TWO `cons' CONJUNCTS                 */                if ( m() == 1 && m_k > 1 && cons( m_k - 1 ) && cons( m_k - 2 ) )                {                    m_k--;                }            }        }        /* THIS CLAUSE WAS ALSO CHANGED BY THE IR-LAB (ADDED T, M, R to L) */        if ( (m_b[m_k] == 'l' || m_b[m_k] == 't' || m_b[m_k] == 'm' || m_b[m_k] == 'r')            && doublec( m_k ) && m() > 1 )        {            m_k--;        }    }    /**     *     * Stem the word placed into the Stemmer buffer through calls to add().     *     * Returns true if the stemming process resulted in a word different from     *     * the input. You can retrieve the result with     *     * getResultLength()/getResultBuffer() or toString().     */    private void stem()    {        m_k = m_i - 1;        if ( m_k > 1 )        {            step0();            // if ("true".equals( (String) System.getProperty("mel.debug")))            // {            // m_logger.debug("[0]" + new String(m_b, 0, m_i) + " -- " + new            // String(m_b, 0, m_k) + " -- " + new String(m_b, 0, m_j));            // }            step1();            // if ("true".equals( (String) System.getProperty("mel.debug")))            // {            // m_logger.debug("[1]" + new String(m_b, 0, m_i) + " -- " + new            // String(m_b, 0, m_k) + " -- " + new String(m_b, 0, m_j));            // }            step2();            // if ("true".equals( (String) System.getProperty("mel.debug")))            // {            // m_logger.debug("[2]" + new String(m_b, 0, m_i) + " -- " + new            // String(m_b, 0, m_k) + " -- " + new String(m_b, 0, m_j));            // }            step3();            // if ("true".equals( (String) System.getProperty("mel.debug")))            // {            // m_logger.debug("[3]" + new String(m_b, 0, m_i) + " -- " + new            // String(m_b, 0, m_k) + " -- " + new String(m_b, 0, m_j));            // }            step4();            // if ("true".equals( (String) System.getProperty("mel.debug")))            // {            // m_logger.debug("[4]" + new String(m_b, 0, m_i) + " -- " + new            // String(m_b, 0, m_k) + " -- " + new String(m_b, 0, m_j));            // }            step5();            // if ("true".equals( (String) System.getProperty("mel.debug")))            // {            // m_logger.debug("[5]" + new String(m_b, 0, m_i) + " -- " + new            // String(m_b, 0, m_k) + " -- " + new String(m_b, 0, m_j));            // }            step6();            // if ("true".equals( (String) System.getProperty("mel.debug")))            // {            // m_logger.debug("[6]" + new String(m_b, 0, m_i) + " -- " + new            // String(m_b, 0, m_k) + " -- " + new String(m_b, 0, m_j));            // }        }        m_iEnd = m_k + 1;        m_i = 0;    }    /**     *     * Perform stemming on the input parameter string     *     *     *     * @param word     *     *            a string to be stemmed     *     * @return String the stemmed word as a string     */    public String stemWord( String word )    {        String stem = s_empty;        char[] chars = word.toCharArray();        m_b = new char[s_inc];        m_i = 0;        m_iEnd = 0;        for ( int l = 0; l < chars.length; l++ )        {            this.add( chars[l] );        }        //if stop word list has this word - do nothing!        if ( s_stopWords.containsKey( word ) )        {        	stem = (String) word ;        }        else if ( s_exceptionWords.containsKey( word ) )        {            stem = (String) s_exceptionWords.get( word );                    }        else        {        	 this.stem();             stem = this.toString();        }        return stem;    }    /**     *     * get a list of stemmed words in order     *     *     *     * @param str     *     * @return     */    public String[] stemText( String str )    {        BreakIterator word_iterator = BreakIterator.getWordInstance();        /**         *         * word_iterator.setText(str.replace('-',' ')); intrduced instead of         *         * word_iterator.setText(str); to handle cases like :         *         * Plaintiff-Appellee-Cross-Appellant-Cross-Appellee         */        word_iterator.setText( str.replace( '-', ' ' ) );        int start = word_iterator.first();        String word;        // Vector words = new Vector();        ArrayList<String> words = new ArrayList<String>();        for ( int end = word_iterator.next(); end != BreakIterator.DONE; start =            end, end = word_iterator        .next() )        {            word = str.substring( start, end );            if ( !isPunctuation( word ) && !s_stopWords.containsKey( word ) )            {                // System.out.println("[STEMMER: process]" + word);                // words.addElement(stemWord(word));                words.add( stemWord( word ) );            }        }        // String[] stems = new String[words.size()];        // words.copyInto(stems);        String[] stems = (String[]) words.toArray( new String[0] );        return stems;    }    public void initStopWords( String fileName) throws IOException//    private void initStopWords( IRuntimeConfiguration conf ) throws IOException    {        s_stopWords = new Hashtable<String, String>(  );/*        conf.register( STOPWORD_PROP_NAME, this, true, false );        String resourceName =            conf.getString( STOPWORD_PROP_NAME, this, DEFAULT_STOPWORD_LIST );//        Reader r = ResourceLoader.getLoadedResources().getResourceReader( resourceName );        File f = FileResources.getFileResourceAsFile( resourceName );        if( f == null )        {            throw new RuntimeException( "Failed to loaded file resource " + resourceName );        }       */               BufferedReader reader = new BufferedReader( new FileReader ( fileName ) );        String line;        while ( (line = reader.readLine()) != null )        {            s_stopWords.put( line, s_empty );        }        reader.close();    }    public void initExceptionWords(  String fileNm)            throws IOException      //  private void initExceptionWords( IRuntimeConfiguration conf )   //     throws IOException    {        s_exceptionWords = new Hashtable<String, String>(  );/*        conf.register( EXCEPTION_WORD_PROP_NAME, this, true, false );        String resourceName =            conf.getString( EXCEPTION_WORD_PROP_NAME, this,                DEFAULT_EXCEPTION_WORD_LIST );//        Reader r = ResourceLoader.getLoadedResources().getResourceReader( resourceName );        Reader r = new FileReader(FileResources.getFileResourceAsFile( resourceName ));        BufferedReader reader = new BufferedReader( r );*/        BufferedReader reader = new BufferedReader( new FileReader (fileNm));        String line;        while ( (line = reader.readLine()) != null )        {            StringTokenizer st = new StringTokenizer( line, "," );            if ( st.countTokens() == 2 )            {                String word = st.nextToken();                String stem = st.nextToken();                s_exceptionWords.put( word, stem );            }        }        reader.close();    }}